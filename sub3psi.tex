\section{Application to PSI}
\label{sec:psi}
The main application of \OPPRF is to propose the semi-honest-secure \textbf{multi-party private set intersection (multi-party PSI)}. Motivated by the problem of PSI for the collusion\ref{subsec:psicoll}, we describe and prove our PSI protocols security in the context of MPC where an arbitrary subset of the parties are corrupted.  

We first propose a three-party PSI protocol which is a special case of multi-party PSI protocol where it is easy to prove the protocol secure against any $t<2$ parties colluded. Our second protocol is a $n$-party protocol ($n >3 $) and is secure against up to an arbitrary subset of the $t<n-1$ corrupted parties. Our third protocol shows how to make the previous protocol secure against up to $t<n$ parties corrupted. %Our results are more efficient than prior works. We compare computation and communication complexity in Table

In all our protocols, $X_i={x^1_i, \ldots, x^m_i}$ denotes the set of party $P_i$.  Similar to two-parties PSI case, the main building block of multi-party PSI is a subprotocol for private set inclusion. Here $P_1$ has a single item $x^*_1$, other party $P_i$ have a set $X_i$ of $m$ items. $P_1$ is to learn whether $x^*_1 \in \bigcap\limits_{i=0}^n X_i$ (as well as the size $m$), while other parties learns nothing. Indeed, our protocol also works in case that each party has a set $X_i$ which is different size of items but the protocol leaks the size. In the sake of simplicity, we assume that each party have the set with the same size and we describe only the set-inclusion subprotocol. 

For our purpose, we first describe the hashing techniques for bucket allocation that is popular in two-party PSI protocol \cite{eurocrypt:FNP04, DBLP:conf/uss/Pinkas0SZ15,DBLP:conf/uss/Pinkas0Z14}. It was introduced to reduce the number of comparisons that have to be computed. The idea is that if an item is in the intersection, $n$ parties should maps this item in the same bin. Consequently, the protocol only need to compute the intersection of items that was located to the same bin. Let's assume all parties agree on three hash functions $\{H_1, H_2, H_3\}$. Now, party $P_1$ hashes his items $X_1={x^1_1, \ldots, x^m_1}$ into $1.2m$ bins using Cuckoo hashing defined by using three above hash functions $\{H_1, H_2, H_3\}$. After the certain number of times, if the insertion attempts of the item $x^j_1, j \in [m]$ to $[1.2m]$ bins  fails,  he put this item is in the stash bins in an arbitrary order; otherwise $x^j_1$ is in the bin \#$b(x^j_i) \in [1.2m]$. Since $P_1$ uses Cuckoo hashing technique, each bin has at most one items, except for the stash bin. For privacy requirements, $P_1$ should hide from each other: (1) which bin is empty; (2) the number of item in the stash bin. To handle (1), $P_1$ pads each empty bin \#$j$ by a random value. For (2), the protocol define in advance the maximum number of stash items $s$ that is defined in Table \ref{tbl:params}, and pad random item to this number.  For other parties $P_i$, they hash their items $X_i=\{x^1_i, \ldots, x^m_i\}$ into $1.2m$ bins using 3 hash functions $\{H_1, H_2, H_3\}$. Obliviously, if $m$ items are mapped to $n$ bins using 3 hash function, then the number of items in each bin is three in average. Again, privacy requires each party hide from each other how many items in his bin. Thus, they pad each bin \#$j$ to $\beta$ items using distinct dummy values, where $\beta$ is defined in advance in Table \ref{tbl:params}. For the correctness, $P_i$ also need to pad $s$ stash bin \#$i$ by the set $X_i$. %Thus, the total number of dummy values in $P_i$'s bin is $1.2(\beta-3)m$. It increases the communication cost of sending the mask of dummy value by $1.2\kappa(\beta-3)m$ bit.


\todo{\textbf{what is probability to find $B$ from $n=2^{20}$ items? => if it is higher, then we can do PSI without hashing technique! => reduce 3 times cost as P* and P1 performs \OPPRF}}


In the sake of simplicity, we assume each parties have $1.2m+s$ bins. From now, we only consider the set-inclusion subprotocol for the in \#$1$ as example. Let  We denote that $r_1$ is the item in bin \#$1$ of $P_1$ after applying bucket allocation. $r^{j}_i $ denotes the $j^{th}$ respective ``real" item of in bin \#$1$ of party $P_i, 1<i\leq n$. Note that the total number of ``real" items $m_i$ is less than or equal to $\beta$ given by Table \ref{tbl:params}.

\subsection{Three-Party Private Set Intersection}
\label{sect:3psi-construction}
We first describe a simple case of the multi-party PSI, the PSI protocol for three parties. This protocol is presented in Figure~\ref{fig:3psi} and work based on \batchOPRF function $\widetilde F$, \OPPRF function $F$, and 2-party \PSI. The parties $P_1$ and $P_2$ start by jointly performing a \batchOPRF protocol on their same bin with receiver $P_1$ and sender $P_2$. $P_1$ inputs $r_1$ and receives $\widetilde F_{k}(r_1)$ while sender $P_2$ receives the related key $k$. $P_2$ computes a pair $(r^{j}_2, y^{j}_2) =\big(r^{j}_2,\widetilde F_{k}(r^{j}_2)\big)$ for each ``real" item  $r^{j}_2$ in $P_2$'s bin. Note that if exits $r_1=r^{j}_2$ then $P_1$ has $y^{j}_2$ which is equal to  $\widetilde F_{k}(r_1)$. Moreover, \batchOPRF construction hide the size of Sender's set from receiver and the output of \batchOPRF is pseudorandom. To hide from each other how many ``real" items in his bin for next step he pad the bin to $\beta$ items using distinct dummy values ${r}^j_2$, where $\beta$ is defined in advance in Table \ref{tbl:params}. $P_2$ makes a pair $({r}^j_2, {y}^{j}_2)$ by choosing  $\bar{y}^j_2 \from\bool^\kappa$ at random, $ m_i<j\leq \beta $

Next step is that $P_2$ and $P_3$ perform non-adaptive \OPPRF protocol where $P_2$ is the sender with $\beta$ pairs from the previous step $\P={(r^1_2,y^1_2),\ldots,{r}^{\beta}_2,{y}^{\beta}_2) }$ and $P_3$ is the receiver with his ``real" items $\{r^{1}_3, \ldots, r^{m_3}_3\}$. After the non-adaptive \OPPRF protocol, $P_3$ receives the corresponding value $y^j_3$ for each choice string $r^j_3$. From the properties of \OPPRF, $y^j_3=y^j_2$ if $r^j_3=r^j_2$, otherwise $y^j_3$ looks random to $P_3$. 

Now, $P_3$ and $P_1$ play two-party set-inclusion PSI protocol where receiver $P_1$ input is $\widetilde F_{k}(r_1)$ from first step and sender $P_3$ inputs are $\beta$ items which includes $m_3$ values $y^j_3$ received from second step and $\beta-m_3$ dummy values to hide a real size of his set. It is clear that if $r_1=r^j_2=r^{j'}_3$ then $\widetilde F_{k}(r_1)$ is the intersection item in the last step since $\widetilde F_{k}(r_1)=y^j_2=y^{j'}_3$

\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of $P_1$:} an item $r_1 \in \{0,1\}^*$.
				
					{\sc Input of $P_2, P_3$:} $R_i=\{r^1_i, \ldots, r^{m_i}_i\} \subseteq\{0,1\}^*$ from each party $P_i, i \in \{2,3\}$, where $m_i$ is the size of $P_i$ set ($m_i \leq \beta$)
								
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
						\item  A \batchOPRF function $\widetilde F$ 
					\item   non-adaptive \OPPRF function $F$;	
					\item   two-party \PSI function $\bar F$ in \todo{section \ref{jj}};	
					\item max. number of items $\beta$ in a bin , where $\beta$ as defined in Table~\ref{tbl:params}
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item the parties $P_1$ and $P_2$ performs a \batchOPRF with sender $P_2$ on input $R_2$ and receiver $P_1$ on input $r_1$
				\begin{enumerate}
					\item $P_2$ receives $m_2$ random related keys $k_2=\{(k^*,k^j)\}, j \in [m_2]$, 					
					\item $P_1$ receives $y_1=\widetilde F_k(r_1)$ with no information about the keys $k$
					\item $\forall$ $1\leq j \leq m_i$, $P_2$ computes $y^j_2 = F_{k_2}(r^j_2)$, makes a pair $({r}^j_2, {y}^{j}_2)$
				\end{enumerate}
				
				\item $\forall$ $ m_2 < j \leq \beta$, $P_2$ generates a pair $({r}^j_2, {y}^{j}_2)$ by choosing ${r}^j_2 \from\bool^*$,  ${y}^j_2 \from\bool^\kappa$ at random. 			
					
				\item the parties $P_2$ and $P_3$ performs a non-adaptive \OPPRF protocol with sender $P_2$ on inputs $\beta$ points $\P_2=\{ (r^1_2, y^1_2), \ldots, (r^{\beta}_{2}, y^{\beta}_{2}) \}$ and receiver $P_3$ on inputs  $R_3$
				\begin{enumerate} 
					\item $P_2$ receives $m_3$ \todo{$1.2m_3+s$} random keys $\bar{k}_2=\{(\bar{k}^*,\bar{k}'_{j})\}$ \todo{indeed, $\bar{k}^*$ can be chose to equal $k^*$} 
					\item $P_3$  outputs $y^j_3=F( \P_2,\bar{k}_2, r^j_3), j \in [m_3]$	
				\end{enumerate}
			\item $\forall$ $ m_3 < j \leq \beta$, $P_3$ chooses ${y}^j_3 \from \bool^*$ at random.
				\item the parties $P_3$ and $P_1$ performs a \PSI protocol with sender $P_3$ on inputs a set of $\beta$ values $Y_3=\{ y^1_3, \ldots, y^{\beta}_{3} \}$ and receiver $P_1$ on inputs  $y_1$
				\begin{enumerate} 
					\item $P_3$ receives nothing
					\item $P_1$ outputs $\{y_1\} \cap Y_3$	
			\end{enumerate}		
	\end{enumerate}		
		\end{minipage}
	}
\caption{Three-Party PSI protocol}
\label{fig:3psi}
\end{figure}


\begin{theorem}(Privacy)
	\label{thm:sotpriv}
	The \OPPRF protocol in \figureref{fig:3psi} securely realizes the  functionality of \figureref{fig:setinclfunc} for three parties in the presence of semi-honest adversaries, provided that:
	\begin{itemize}\addtolength{\itemsep}{-6pt}
			\item  A \batchOPRF function $\widetilde F$ 
		\item   non-adaptive \OPPRF function $F$;	
		\item   two-party \PSI function $\bar F$ in \todo{section \ref{jj}};	
		\item max. number of items $\beta$ in a bin , where $\beta$ as defined in Table~\ref{tbl:params}
	\end{itemize}
\end{theorem}

\begin{proof}
	
	\medskip

Intuitively, as far as no more than 2 parties collude  the security of the protocol follows from the fact that the \batchOPRF, \OPPRF, and two-party \PSI are secure. Moreover, each parties $P_2$ and $P_3$ receives the PRF mask which reveal no information about the sub-intersection. Due to lack of space, we skip the proof of security of the protocol in this case. 

We formalize the the security of the protocol when an arbitrary two parties in the  colluded by considering 3 cases:

	\noindent{\bf Simulating \adv when $P_1$ and $P_2$ are compromised:} It is easy to see that the view of \adv on $P_3$ input is perfected simulated since $P3$ interacts as a receiver with a sender $P_2$ via \OPPRF, and performs a sender in \PSI with $P_1$ as receiver. Based on \OPPRF and \PSI functionality  \adv does not receive any extra information in this case.

	\noindent{\bf Simulating \adv when $P_2$ and $P_3$ are compromised} 
$P_1$ and $P_2$ performs \batchOPRF where $P_2$ is a sender. Thus, $P_2$ receives nothing in this step. Moreover, $P1$ interacts with $P_3$ via \PSI which reveal no information about $P_1$ input.  Therefore, the view of \adv on $P_3$ input is perfected simulated.

	\noindent{\bf Simulating \adv when $P_1$ and $P_3$ are compromised} 
$P_1$ and $P_3$ exchange their input information. From \OPPRF, if \Adv see that $y^{j'}_3$ is equal to \batchOPRF value of $P_1$'s input then \Adv learns $P_2$'s input $r^j_2$ which is equal to $r^{j'}_3$. In this case, $r^j_2$ is the intersection item of 3 parties. Therefore, the view of \Adv in \textit{Ideal} world and \textit{Real} world are the same. If $y^{j'}_3$ is not equal to \batchOPRF value of $P_1$'s input, then \Adv view on $P_2$'s input are random. 
\end{proof}