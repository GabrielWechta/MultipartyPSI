%!TEX root = main.tex

\section{\SSOT construction}

We present our constructions as follows.  We start with the default \SSOT  (1-out-of-$n$ KS, defined in \figureref{fig:1ssotfunc}).  Next, in Section~\ref{sect:constrnSSOT} we give a protocol for $m$-times  \SSOT  in non-adaptive settings ($m$-out-of-$n$ KS, defined in \figureref{fig:nssotfunc}). We also prove the protocols secure against semi-honest adversaries.
 

\subsection{Notation}
\subsection{The \SSOT construction}
\label{sect:constr1SSOT}

We construct a \SSOT protocol based on batched related-key oblivious pseudo-random function (\batchOPRF) \cite{CCS:KKRT16}. Recall the  \batchOPRF functionality that the receiver provides an input $x^*$; the functionality $F$ choose a random key $k$, gives $k$ to the sender and $F_k(x^*)$ length $|F|$ to the receiver. In other words, the sender can compute $F_k(x_i)$ for any $x_i$ while the receiver learns only $F_k(x^*)$ for a single value $x^*$. 

The basic idea of the \SSOT construction is that the sender $\SS$ uses the output of $F_k(x_i)$ as a key $sk_i$ to encrypt the corresponding payload $p_i$, and send to $\RR$ each encryption string $\Enc(sk_i,p_i)$ together with RO hash of the key used in this encryption.  The $\RR$ computes the RO hash of his key $F_k(x^*)$ and may obtain a single key while he will have no information to guess other keys. He may decrypt a cipher-text corresponding to his key $sk^*=F_k(x^*)$ and get the real payload.   This technique is similar to OT extension protocols  \cite{C:IKNP03,C:KolKum13}. However, $\RR$ maybe not able to decrypt the corresponding cipher-text in case of that his search word is not in the sender's set of keyword since he does not have the key corresponding to the RO hash received from $\SS$, thus he may not decrypt any the cipher-text. It means that the receiver outputs nothing which is not true in the \SSOT functionality. Therefore, instead of sending RO hash of the encrypted key $sk_i$, the sender does the following steps:
\begin{itemize}
	\item look at $n$ encrypted keys $sk_i=F_k(x_i)$ length $|F|$, choose $m=\floor{\log(n)}+1$ bit positions $B=\{b_1,  \ldots, b_m\}$, under which the keys are distinct. Note that the length of $F$ is larger than $m$, thus it is able to find the set $B$. For example, length $|F|=128$ while the number of pairs $n=2^{24} \Rightarrow m=\floor{\log(n)}+1=25$.
	\item run a mapping function $M: \{0,1\}^{|F|} \rightarrow \{0,1\}^m$ to represent each $sk_i$ in $m$ positions defined by $B$, \textit{i.e.}, $\tilde{sk}_{i}=M(sk_i)$
	\item generate $(2^m-n)$ strings $\tilde{sk}_{n+i}$ length $m$ to get $2^m$ distinct values $\tilde{sk}_{i}$ length $m$
	\item for $1\leq i \leq n$, $\SS$ sends RO hash of $\tilde{sk}_{i}$ along with each encryption string $\Enc(sk_i,p_i)$. For $n < i \leq 2^m$, $\SS$ sends RO hash of $\tilde{sk}_{i}$ along with $\Enc(r_i,p^*)$, where $r_i$ are random string.
	\item send the function $M$, and set $B$	to $\RR$
\end{itemize}


By adding on these above steps, $\RR$ knows function $M$ and the set $B$, he can compute $\tilde{sk^*}=M(sk^*)$, and always gets the string corresponding to his key. Note that if his search word is in the sender's set of keyword $\{sk_1, \ldots , sk_n\}$, then he can decrypt a \textit{right} cipher-text using $sk^*$, and get the \textit{real} payload. Otherwise, he decrypt a random string created by $\SS$.


Moreover, we require an encryption scheme $\Enc$ one-time secure, \textit{i.e.}, for all $m, m'$, the distributions $\Enc(k,m)$ and $\Enc(k,m')$ (induced by random choice of $k$), are indistinguishable. 

Our \SSOT protocol is presented in \figureref{fig:Cons1ssot}. 


\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of \SS:} \numinst\ pairs  
				$\{ (x_0, p_0), \ldots, (x_{n-1}, p_{n-1}) \}$, and $\hat{p}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$,  and $p_i,\hat{p} \in \{0,1\}^\ell$.
				
				\medskip
				
				
				{\sc Input of \RR:} selection strings $x^* \in \bool^*$.
				
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
					\item  A \batchOPRF function $F$ with output length $\kappa$. 
					\item A mapping function $M:\bool^\kappa \to \bool^m$, where $m=\floor{\log(n)}+1$ as defined above.
						\item A $\kappa$-Hamming correlation-robust  $H:\bool^m \to \bool^\kappa$, 
					\item A suitable encryption scheme $\Enc$ as defined above.
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item $\forall$ $0\leq i < \L$, \SS\ computes $sk_i = F(x_i)$.

				\item \SS\ chooses $m$ bit positions $B=\{b_1,  \ldots, b_m\}$, under which the $sk_i , i \in [0,\L],$ are distinct, sends it to \RR 
				
				\item $\forall$ $0\leq i < \L$, \SS\ computes $\tilde{sk}_{i} = M(sk_i)$, and chooses $2^m-n$ values $\tilde{sk}_{i}, i \in [\L+1, 2^m-\L]$ such that $2^m$ $\tilde{sk}_{i}$ are distinct.
				
				\item \SS\ chooses $\sec \from\bool^\csp$ at random. Let $\seci$ denote the $i$-th bit of \sec.
					
				\item  $\forall$ $0\leq i < \L$, \SS\ computes $y_i = \Enc(sk_i, p_i)$
				 \\$\forall$ $\L < i < 2^m$, \SS\ choose $y_i \from\bool^\kappa$ at random
				 \\ $\forall$ $0\leq i < 2^m$, \SS\ sends $\{H(\tilde{sk}_{i}), y_i\}$ to \RR\
				\item \RR\ receives $\{H(\tilde{sk}_{i}), y_i\}$, $i\in[2^\numinst]$ and does the following: 
				\begin{itemize}
					\item computes $sk^* = F(x^*)$
					\item computes $\tilde{sk^*} = M(sk^*)$
					\item find $i$ such that $H(\tilde{sk^*})= H(\tilde{sk_i})$
					\item output $z=\Dec(sk^*, y_i)$
				\end{itemize}
				
			
			\end{enumerate}
			
			
		\end{minipage}
	}
	\caption{1-out-of-$n$ \SSOT protocol}
	\label{fig:Cons1ssot}
\end{figure}





\begin{theorem}
\label{thm:sot}
The \SSOT protocol in \figureref{fig:Cons1ssot} securely realizes the  functionality of \figureref{fig:1ssotfunc} in the presence of semi-honest adversaries, where ....
\end{theorem}


\begin{proof}
%
When using the abstraction of our SSOT functionality, the proof is elementary.

In both cases it is straightforward to check that the simulation is perfect.
\end{proof}

\subsection{The non-adaptive \SSOT construction}
\label{sect:constrnSSOT}
 