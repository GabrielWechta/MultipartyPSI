\section{Technical Preliminaries}
\label{sect:prelims}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Our \SSOT Variant}
\label{sec:ssotfunc}

In this section we formally describe the variant \OPPRF definition. In \OPPRF, the sender $\SS$  has a set of $n$ points $\P = \{ (x_i, y_i) \}$. All $x_i$ are distinct with an arbitrary length, all $y_i$ are pseudorandom and should be padded to a fixed length. The receiver $\RR$ has a value $x^*$. If there is a pair $\{ (x_i, y_i) \}$ in $\P$ that $x_i$ is equal to $x^*$, $\RR$ would receives the corresponding "true" value $y_i$. Otherwise, $\RR$'s output is a random value that cannot distinguish from $y_i$.

When viewing our \OPPRF functionality in term of search keyword and payload, the main difference of our \OPPRF functionality with the \KS\cite{TCC:FIPR05} functionality is in the receiver's output. In \OPPRF, if the \textit{search word} of the receiver is not in the set of the \textit{keyword} of the sender, $\RR$ receives the \textit{dummy} payload that is indistinguishable with the \textit{real} payload $\{y_i\}$. In other words, unlike the \KS functionality\cite{TCC:FIPR05} in case that $\RR$ receives nothing if his \textit{search word} is not equal to any \textit{keyword} of $\SS$, in our \OPPRF  $\RR$ also receives the random "fake" corresponding payload to his \textit{search word}. The formal definition of our \OPPRF is given in  
\figureref{fig:1ssotfunc}. For the privacy, our \OPPRF requires both parties learns no additional information beyond their output that are defined by the definition in \figureref{fig:1ssotfunc}. 


\begin{figure}[htb]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			The functionality is parameterized by a relaxed {\bf programmable PRF} $F$,  a fixed length parameter $l$, and by two parties: a {\bf sender} and {\bf receiver}.
			
			\medskip
			On input $n$ pairs $\P=\{ (x_1, y_1), \ldots, (x_{n}, y_{n}) \}$ from the sender, where $x_i \in \{0,1\}^*$ are all distinct and $y_i$ are in a pseudorandom distribution $\{0,1\}^\ell$; \\
			On input $x^* \in \{0,1\}^*$ from the receiver:
			\begin{itemize}
				\item Choose random components for seeds to the PRF: $k^*, k_1, \ldots, k_m$ and give these to the sender.
				\item Give $ F( \P,(k^*,k_1), x^*)$ to the receiver.
			\end{itemize}
			
		\end{minipage}
	}
	\caption{The \OPPRF ideal functionality}
	\label{fig:1ssotfunc}
\end{figure} 

\todo{need: The non-adaptive $m$-times \OPPRF ideal functionality?}

In \figureref{fig:1ssotfunc} definition, the Receiver $\RR$ has only a single value for the programmable PRF. In fact, Receiver may repeat the above procedure many times. To achieve an efficient solution in this case, we describe an extended version of \OPPRF (called as \textit{non-adaptive}) that allows $\RR$ does multiple queries, but, at the same time. It means that our extended version limits these queries defined before running the procedure. An ideal functionality of the \textit{non-adaptive} \OPPRF is given in \figureref{fig:nssotfunc}

\begin{figure}[htb]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			The functionality is parameterized by a relaxed {\bf programmable PRF} $F$,  a fixed length parameter $l$, and by two parties: a {\bf sender} and {\bf receiver}.
			
			\medskip
			On input $n$ pairs $\P=\{ (x_1, y_1), \ldots, (x_{n}, y_{n}) \}$ from the sender, where $x_i \in \{0,1\}^*$ are all distinct and $y_i$ are in a pseudorandom distribution $\{0,1\}^\ell$; \\
			On input $m$ $\{x^*_1, \ldots, x^*_m\}$ from the receiver, where $x^*_i \in \{0,1\}^*$:
			\begin{itemize}
				\item Choose random components for seeds to the PRF: $k^*, k_1, \ldots, k_m$ and give these to the sender.
				\item Give $ F( \P,(k^*,k_1), x^*_1), \ldots, F(\P, (k^*,k_m), x^*_m)$ to the receiver.
			\end{itemize}
		
	\end{minipage}
}
\caption{The non-adaptive $m$-times \OPPRF ideal functionality}
\label{fig:nssotfunc}
\end{figure} 



%%%%%%%%%%%
\subsection{PSI }
\subsubsection{PSI collusion}
\subsubsection{PSI functionality}
\label{sec:psifunc}
In \figureref{fig:psifunc} we formally describe the PSI functionality.% we achieve. The sender has $n$ pairs $\{x_i, y_i\}$, the receiver has $m$ strings $x^*_j$. For each $j \in [1,m]$, the SSOT functionality allows the receiver to learn the $y_i$ if $x^*_j=x_i$, otherwise he learns a random string $\$$ that is randomly chosen by the sender.

\begin{figure}[htb]\centering
\framebox{\begin{minipage}{0.95\linewidth}
		
		The functionality is parameterized by the number of parties $n$,  the size of the parties' sets $m$, and the bit-length of the parties' items $\sigma$. 
		\begin{itemize}
			\item On input $X_i=\{x^1_i, \ldots, x^m_i\} \subseteq\{0,1\}^\sigma$ from each party $P_i$.
			
			\item Give output $\bigcap\limits_{i=0}^n X_i$ to $P_i$.
		\end{itemize}
	\end{minipage}
}
\caption{PSI ideal functionality.}
\label{fig:psifunc}
\end{figure} 

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:
