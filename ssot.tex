%!TEX root = main.tex

\section{\SSOT construction}

We present our constructions as follows.  We start with the default \SSOT  (1-out-of-$n$ KS, defined in \figureref{fig:1ssotfunc}).  Next, in Section~\ref{sect:constrnSSOT} we give a protocol for $m$-times  \SSOT  in non-adaptive settings ($m$-out-of-$n$ KS, defined in \figureref{fig:nssotfunc}). We also prove the protocols secure against semi-honest adversaries.
 

\subsection{Notation}
\subsection{\SSOT construction}
\label{sect:constr1SSOT}

We construct a \SSOT protocol based on batched related-key oblivious pseudo-random function (\batchOPRF) \cite{CCS:KKRT16}. Recall the  \batchOPRF functionality that the receiver provides an input $x^*$; the functionality $F$ choose a random key $k$, gives $k$ to the sender and $F_k(x^*)$ length $\sigma=\sigma(\kappa)$ to the receiver. In other words, the sender can compute $F_k(x_i)$ for any $x_i$ while the receiver learns only $F_k(x^*)$ for a single value $x^*$. 

The basic idea of the \SSOT construction is that the sender $\SS$ uses the output of $F_k(x_i)$ as a key $sk_i$ to encrypt the corresponding payload $p_i$, and send to $\RR$ each encryption string $\Enc(sk_i,p_i)$ together with RO hash of the key used in this encryption.  The $\RR$ computes the RO hash of his key $F_k(x^*)$ and may obtain a single key while he will have no information to guess other keys. He may decrypt a cipher-text corresponding to his key $sk^*=F_k(x^*)$ and get the real payload.   This technique is similar to OT extension protocols  \cite{C:IKNP03,C:KolKum13}. However, $\RR$ may not be able to decrypt the corresponding cipher-text in case of that his search word is not in the sender's set of keyword since he does not have the key corresponding to the RO hash received from $\SS$, thus he may not decrypt any the cipher-text. It means that the receiver outputs nothing which is not true in the \SSOT functionality. Therefore, instead of sending RO hash of the encrypted key $sk_i$, the sender does the following steps:
\begin{itemize}
	\item look at $n$ encrypted keys $sk_i=F_k(x_i)$ length $\sigma=\sigma(\kappa,n)=\kappa+m$, where $m=\floor{\log(n)}+1$, choose $m$ bit positions $B=\{b_1,  \ldots, b_m\}$, under which the keys are distinct.%. Note that the length of $F$ is larger than $m$, thus it is able to find the set $B$. For example, length $|F|=128$ while the number of pairs $n=2^{24} \Rightarrow m=\floor{\log(n)}+1=25$.
	\item run a mapping function $M: \bool^\sigma \rightarrow \bool^m$ that represents each $sk_i$ in $m$ positions defined by $B$, \textit{i.e.}, $\tilde{sk}_{i}=M(sk_i)$
	\item generate $(2^m-n)$ strings $\tilde{sk}_{n+i}$ length $m$ to get $2^m$ distinct values $\tilde{sk}_{i}$ length $m$
	\item for $1\leq i \leq n$, $\SS$ sends RO hash of $\tilde{sk}_{i}$ along with each encryption string $y_i\Enc(sk_i,p_i)$. For $n < i \leq 2^m$, $\SS$ sends RO hash of $\tilde{sk}_{i}$ along with $y_i$, where $y_i$ is random string.
	\item send the function $M$, and set $B$	to $\RR$
\end{itemize}


By adding on these above steps, $\RR$ knows function $M$ and the set $B$, he can compute $\tilde{sk^*}=M(sk^*)$, and always gets the string corresponding to his key. Note that if his search word is in the sender's set of keyword $\{sk_1, \ldots , sk_n\}$, then he can decrypt a \textit{right} cipher-text using $sk^*$, and get the \textit{real} payload. Otherwise, he decrypt a random string created by $\SS$.


Moreover, we require an encryption scheme such that for all $m$, the distribution $Enc(sk, m)$ (induced by random choice of $sk$), is pseudorandom. In other words,the encryption scheme is one-time secure with a random choice of the encrypted key. Our \SSOT protocol is presented in \figureref{fig:Cons1ssot}. 

\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of \SS:} $n$ pairs  
				$\{ (x_0, p_0), \ldots, (x_{n-1}, p_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$,  and $p_i \in \{0,1\}^\ell$.
				
				\medskip
				
				{\sc Input of \RR:} selection strings $x^* \in \bool^*$.
				
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
					\item  A \batchOPRF function $F_k$ with output length $\sigma$, where $k$ is random key.
					\item A mapping function $M:\bool^\sigma \to \bool^m$, where $m=\floor{\log(n)}+1$ as defined above.
					\item A random hash  $H:\bool^m \to \bool^\kappa$, 
					\item A suitable encryption scheme $\Enc$ as defined above.
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item the parties performs a \batchOPRF with sender \SS\ and receiver \RR\
				\begin{enumerate}
					\item \SS\ receives a random key $k$, 					
					\item \RR\ receives $sk^*=F_k(x^*)$
					\item $\forall$ $0\leq i < \L$, \SS\ computes $sk_i = F_k(x_i)$.
				\end{enumerate}
				
				\item \SS\ chooses $m$ bit positions at random $B=\{b_1,  \ldots, b_m\}$, under which the $sk_i , i \in [0,\L],$ are distinct, sends it to \RR 
				
				\item 
				\begin{enumerate}
					\item $\forall$ $0\leq i < \L$, \SS\ computes $\tilde{sk}_{i} = M(sk_i)$
					\item $\forall$ $\L \leq i < 2^m$, \SS\ chooses $\tilde{sk}_{i} \from\bool^m$ at random, such that all $2^m$ values $\tilde{sk}_{i}, i \in [0, 2^m-1]$, are distinct.				
				\end{enumerate}
				\item  
				\begin{enumerate}
					\item $\forall$ $0\leq i < \L$, \SS\ computes $y_i = \Enc(sk_i, p_i)$
					\item $\forall$ $\L \leq i < 2^m$, \SS\ choose $y_i \from\bool^\kappa$ at random
				\end{enumerate}
				\item $\forall$ $0\leq i < 2^m$, \SS\ sends $\{H(\tilde{sk}_{i}), y_i\}$ to \RR\
				
				\item \RR\ receives $Y=\{H(\tilde{sk}_{i}), y_i\}$, $i\in[2^\numinst]$ and does the following: 
				\begin{enumerate}
					\item computes $\tilde{sk^*} = M(sk^*)$
					\item find $i$ such that $H(\tilde{sk^*})= H(\tilde{sk_i})$
					\item output $p=\Dec(sk^*, y_i)$
				\end{enumerate}				
				
			\end{enumerate}				
		\end{minipage}
	}
	\caption{1-out-of-$n$ \SSOT protocol}
	\label{fig:Cons1ssot}
\end{figure}


\begin{theorem} (Correctness)
	\label{thm:sotcorr}
In semi-honest setting, on the sender \SS\ inputs $n$ pairs $\{ (x_0, p_0), \ldots, (x_{n-1}, p_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$,  and $p_i \in \{0,1\}^\ell$, the receiver \RR\ inputs $x^*$. After running protocol in \figureref{fig:Cons1ssot}, \RR\ outputs $p_i$ if $x^*=x_i$, or random value $\hat{p}$ if no such $i$ exists, where $\hat{p}$ depends on $x^*$ and is indistinguishable with all values $p_i$
\end{theorem}
\begin{proof}
	Let's consider two following cases:
	\begin{enumerate}
		\item exists $i \in [0, \L-1]$ such that $x^*=x_i$: it is easy to see from \batchOPRF that $F_k(x^*)=F_k(x_i) \Rightarrow sk^* = sk_i$. Thus, a RO hash  of $sk^*$ is equal to $H(\tilde{sk_i})$. \RR\  obtains the corresponding ciphertext, decrypts it using his key $sk^*=F_k(x^*)=sk_i$, and gets the corresponding payload $p_i$.
		
		\item no exist $i \in [0, \L-1]$ such that $x^*=x_i$: from the properties of \batchOPRF protocol, for all $0 \leq i < \L$,  $F_k(x^*) \ne F_k(x_i) \Rightarrow sk^* \ne sk_i \Rightarrow \tilde{sk^*} \ne \tilde{sk_i}$. However, \SS\ chooses $2^m-n$ random $sk_i$ in step 3(b) to fill out all cases of value $\tilde{sk_i}$. Note that length of $sk_i$ is $m$. There exist $i \in [\L, 2^m-1]$ such that $\tilde{sk^*}  = \tilde{sk_i}$. Therefore, \RR\  obtains the corresponding random ciphertext generated by step 4(b) , decrypts it using his key $sk^*=F_k(x^*)=sk_i$, and gets the random payload $\hat{p}$ which depends on value $x^*$. Since the distribution of $\Enc$ scheme is pseudorandom, $\hat{p}$ is indistinguishable with all values $p_i$.
	\end{enumerate}
Hence, the protocol is correct.
\end{proof}


In order to show that both parties do not learn any additional information more than in the ideal functionality defined by \ref{fig:1ssotfunc}, our protocol must satisfy two following properties:
\begin{itemize}
	\item the view of a semi-honest sender \SS\ are indistinguishable in the case that \RR\  inputs $x$ and the case that his input is $x'$.  
	\item  the view of semi-honest receivers \RR\ in the real protocol and his view in the ideal protocol on any inputs $\{ (x_0, p_0), \ldots, (x_{n-1}, p_{n-1}) \}$ of the sender \SS\ are indistinguishable. Especially, the view of \RR\ in case that his search word is in the keyword set of \SS\ and it is \textit{not} in this set, are indistinguishable.
\end{itemize}


\begin{theorem}(Privacy)
\label{thm:sotpriv}
The \SSOT protocol in \figureref{fig:Cons1ssot} securely realizes the  functionality of \figureref{fig:1ssotfunc} in the presence of semi-honest adversaries, provided that:
\begin{itemize}\addtolength{\itemsep}{-6pt}
	\item  A \batchOPRF function $F_k$ with random key $k$ and output length $\kappa$.
	\item A mapping function $M:\bool^\kappa \to \bool^m$, where $m=\floor{\log(n)}+1$ as defined above.
	\item A $\kappa$-RO hash  $H:\bool^m \to \bool^\kappa$, 
	\item A one-time secure encryption scheme $\Enc$.
\end{itemize}
Here,  $\kappa$ is the computational security parameter.
\end{theorem}

\begin{proof}

\medskip
\noindent{\bf Simulating \SS.} 
According the privacy of the \batchOPRF protocols~\cite{CCS:KKRT16}, it is trivial to argue that the view of a semi-honest \SS\ can be perfectly simulated. Indeed, the view of \SS\ in the protocol is a random key $k$ received from the \batchOPRF and uniformly random OPRF values $F_k(x_i)$. Therefore, the view of a semi-honest sender \SS\, in the case that \RR\  uses $x$ and the case that he uses  $x'$, are indistinguishable. 

\medskip
\noindent{\bf Simulating \RR.} On the view of a semi-honest receiver \RR\ in the protocol, the only external messages it receives are the \batchOPRF output $sk^*=F_k(x^*)$ at step 1(a), the $m$ bit positions $B=\{b_1,  \ldots, b_m\}$ that \RR\ knows all first $n$ encrypted keys $sk_i$ are distinct in step 2, and the set Y in step 6. Therefore, the simulated view is as follows:
 \begin{itemize}
 	\item Call the ideal \SSOT functionality with input $x^*$. Let $p$ denote as the output received from ideal-world trusted party TP.
 	
 	\item Call the ideal \batchOPRF functionality with input $x^*$. Let $sk^*=F_k(x^*)$ denote as the output received from ideal-world trusted party TP.
 	
 	
 	\item Chooses $m$ bit positions at random $B=\{b_1,  \ldots, b_m\}$ and send it to \RR\ on behalf of $\SS$ in step 2.
 	
 	\item In step 6, simulate the $Y$ messages from $\SS$ as follows:
 	compute  $\tilde{sk^*} = M( sk^*)$, and $y_i = \Enc( sk^*, p)$, and set a pair $\{H(\tilde{sk^*}), y_i \}$ to be a random permutation of $Y$ and $2^m-1$ other random pairs.
 	
 \end{itemize}

To prove that this simulated view is indistinguishable from the real one, we first consider the value that \SS\ uses as a key to $\Enc$. This encrypted key is the output of \batchOPRF, thus it is a pseudorandom string. However, the protocol also gives knowledge of the RO hash of $m$ bit string of the key as $H(M( sk^*))$. Since the output length of \batchOPRF is $\sigma=\kappa+m$ in our protocol, probability for \RR\ learning the key is $1/2^\kappa$. Therefore, choosing $m$ bit positions in step 2 can be simulated independently on the input of $\SS$. In other words, step 1(a), step 2, and step 6(a) are perfectly simulated.

Now, consider the encrypted scheme $\Enc$,  we require the distribution of $\Enc$ is pseudorandom, thus the real view is indistinguishable from the one in which value of the form  $\Enc(sk_i, p_i)$ in step 4(a) are replaced with random string in step 4(b). 

From the above observation, if the search word $x^*$ is not in the keyword set of \SS\, then the corresponding ciphertext is chosen uniformly. The security of $\Enc$ implies that these ciphertexts are indistinguishable from random strings. In addition, the encrypted key is indistinguishable in the case that search word is in the keyword set or not.  Hence, we see that the simulated view is indistinguishable from the real view, and the protocol is secure.
\end{proof}

\subsection{Non-adaptive \SSOT construction}
\label{sect:constrnSSOT}
We now present the non-adaptive \SSOT construction which allows the receiver does multiple keyword search queries, but the queries must defined before running the protocol. Since our \SSOT protocol is based on \textit{batch} related-key OPRF (\batchOPRF), this protocol shows an efficient solution to reduce the costs in this non-adaptive setting, and have application to our multi-party private set intersection described in \sectionref{sec:psi}. The basic idea of the construction is to use the \textit{hashing to bin} technique that is very popular in two-party PSI protocols~\cite{DBLP:conf/uss/Pinkas0SZ15,DBLP:conf/uss/Pinkas0Z14}. Our  non-adaptive \SSOT protocol is presented in \figureref{fig:Consnssot}. 


\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of \SS:} $n$ pairs  
				$\{ (x_0, p_0), \ldots, (x_{n-1}, p_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$,  and $p_i \in \{0,1\}^\ell$.
				
				\medskip
				
				
				{\sc Input of \RR:} $m$ selection strings $\{x^*_1, \ldots, x^*_m\}$, where $x_i \in \{0,1\}^*$.
				
				
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
					\item   1-out-of-n \SSOT function $F$ 
					\item three random hash $\{H_1, H_2, H_3\}: \{ 0,1\}^* \to [1.2m]$ 
					\item  max. stash size $s$ as defined in Table~\ref{tbl:params}
					\item max. number of items in $\SS$'s bin $\gamma$, where $\gamma$ as defined in Table~\ref{tbl:params}
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item \RR\ hashes his items $X^*=\{x^*_0, \ldots, x^*_{m-1}\}$ into $1.2m$ bins using Cuckoo hashing defined by 3 hash functions $\{H_1, H_2, H_3\}$. After the certain number of times, if the insertion attempts of the item $x^*_i$ to $[1.2n]$ bins  fails,  \RR\ put this item is in the stash bins in an arbitrary order; otherwise $x^*_i$ is in the bin \#$b(x^*_i) \in [1.2n]$.  
				\\
				For $i \in [1.2m+s]$, if bin \#$i$ is empty, then pad this bin using a dummy value $r_i$; otherwise if $x^*_j$ is in bin \#$i$ then set $r_i = x^*_j$. 
				
				\item \SS\ hashes his items $X=\{x_0, \ldots, x_{n-1}\}$ into $1.2m$ bins using 3 hash functions $\{H_1, H_2, H_3\}$. For $i \in [1.2m]$, index all $x_j$ is in bin \#$i$ as $r_{i,j}$, and pad this bin \#$i$ to $\gamma$ items using distinct dummy values $r_{i,k}$; for $i \in [s]$, pad this bin \#$i$ by the set $X$.
				
				\item For $i \in [1.2m]$  the parties performs a 1-out-of-n \SSOT protocol with sender \SS\ and receiver \RR\
			\begin{enumerate}
				\item \RR\ inputs a search word $r_i$, 					
				\item \SS\ inputs $\gamma$ pairs $(r_{i,j}, \hat{p_j})$, where $\hat{p_j}$ is equal to $p_j$ if $r_{i,j}$ is assigned as $x_j$; otherwise $\hat{p_j}$ is random.					
				\item \RR\ outputs $p_j$ if $r_i=x_j$; otherwise, \RR\ receives a dummy value. In other words, if \RR\ receives a payload corresponding to his search word in this bin.
			\end{enumerate}
							
				\item For $i \in [s]$  the parties performs a 1-out-of-n \SSOT protocol with sender \SS\ and receiver \RR\
				\begin{enumerate}
					\item \RR\ inputs a search word $r_i$, 					
					\item \SS\ inputs $n$ pairs $(x_i, p_i)$
					\item \RR\ outputs $p_j$ if $r_i=x_j$; otherwise, \RR\ receives a dummy value. 		
				\end{enumerate}
			
			\end{enumerate}				
		\end{minipage}
	}
	\caption{$m$-out-of-$n$ non-adaptive \SSOT protocol}
	\label{fig:Consnssot}
\end{figure}

\begin{table}\centering
	\framebox{
		\begin{minipage}{0.9\linewidth}\centering
			\begin{tabular}{c | c c c }
				$n$ &  $\beta$ & $s$ \\
				\hline
				$2^8$    & 24& 12  \\
				$2^{12}$ & 25& 6  \\
				$2^{16}$ & 26& 4 \\
				$2^{20}$ & 27& 3  \\
				$2^{24}$ &28 & 2  \\
			\end{tabular}
		\end{minipage}
	}
	
	\caption{Parameters used in \figureref{fig:Consnssot}. $n$ is the size of the parties' input sets; $\beta$ is the maximum bin size for simple hashing; $s$ is the maximum hash size for Cuckoo hashing}
	\label{tbl:params}
\end{table}

The correctness of the non-adaptive \SSOT protocol can be trivially achieved from \theoremref{thm:sotcorr}. For the security, the main difference of the construction with the above 1-out-of-n \SSOT construction is in that in the non-adaptive setting, \SS\ uses Simple hashing and \RR\ uses Cuckoo hashing to assign their item to the bin before running 1-out-of-n \SSOT protocol. The security of the hashing to bin technique had been proved in ~\cite{eprint:PSZ16} when using the parameters defined in Table~\ref{tbl:params}. Therefore, we can skip the proof of correctness and privacy of the protocol in \figureref{fig:Consnssot}



%\begin{theorem}(Privacy)
%	\label{thm:nsotpriv}
%	The non-adaptive \SSOT protocol in \figureref{fig:Consnssot} securely realizes the  functionality of \figureref{fig:nssotfunc} in the presence of semi-honest adversaries, provided that:
%	\begin{itemize}\addtolength{\itemsep}{-6pt}
%		\item  a secure 1-out-of-n \SSOT protocol in \figureref{fig:Cons1ssot} 
%	\item three random hash $\{H_1, H_2, H_3\}: \{ 0,1\}^* \to [1.2m]$ 
%	\item  max. stash size $s$, and max. number of items in $\SS$'s bin $\gamma$ as defined in Table~\ref{tbl:params}
%	\end{itemize}
%\end{theorem}
%
%\begin{proof}
%The proof of security of the non-adaptive \SSOT construction is very similar to that of  \theoremref{thm:sotpriv}. Most importantly,
%\end{proof}
 