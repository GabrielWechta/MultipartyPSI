%!TEX root = main.tex

\section{\OPPRF construction}

We present our constructions as follows.  We start with the default \OPPRF  (1-out-of-$n$ KS) defined in \figureref{fig:1ssotfunc}).  Next, in Section~\ref{sect:constrnSSOT} we give a protocol for $m$-times  \OPPRF  in non-adaptive settings ($m$-out-of-$n$ KS) defined in \figureref{fig:nssotfunc}). We also give the proofs of the protocols secure against semi-honest adversaries.


\subsection{Notation}
\subsection{\OPPRF construction}
\label{sect:constr1SSOT}

We construct a \OPPRF protocol based on batched related-key oblivious pseudo-random function (\batchOPRF) \cite{CCS:KKRT16}. Recall the  \batchOPRF functionality that the receiver provides an input $x^*$; the functionality $\widetilde F$ choose a random key $k$, gives $k$ to the sender and gives $\widetilde F_k(x^*)$ length $\sigma=\sigma(\kappa)$ to the receiver. In other words, the sender has a key $k$, he can compute $\widetilde F_k(x_i)$ for any $x_i$ while the receiver learns only $\widetilde F_k(x^*)$ for a single value $x^*$. 

The basic idea of our \OPPRF construction is that the sender $\SS$ uses the output of $\widetilde F_k(x_i)$ as a key $sk_i$ to encrypt the corresponding value $y_i$, and sends to $\RR$ each encryption string $\Enc(sk_i,y_i)$ together with the RO hash of the key used in this encryption.  The $\RR$ computes the RO hash of his key $\widetilde F_k(x^*)$ and may obtain a single key while he will have no information to guess other keys. He may decrypt a cipher-text corresponding to his key $sk^*=\widetilde F_k(x^*)$ and get the \textit{true} value $y_i$ if $x^*=x_i$.   This technique is similar to the encryption/decryption technique in OT extension protocols \cite{C:IKNP03,C:KolKum13}. However, in this scheme $\RR$ may not be able to decrypt the corresponding cipher-text in case of that his value $x^*$ is not in the sender's set $\{x_i\}$, \textit{i.e.},  he does not have the key corresponding to the RO hash received from $\SS$, thus he may not decrypt any cipher-text. Therefore, the receiver outputs nothing which is not true in the \OPPRF functionality. To handle this problem, instead of sending RO hash of the encrypted key $sk_i$, the sender does the following steps:
\begin{enumerate}
	\item  choose $m$ bit positions $B=\{b_1,  \ldots, b_m\}$ of the encrypted key $sk_i=F_k(x_i)$ length $\sigma=\sigma(\kappa,n)=\kappa+m$, where $m=\floor{\log(n)}+1$, such that $n$ encrypted keys $sk_i$ are distinct under these positions.%. Note that the length of $F$ is larger than $m$, thus it is able to find the set $B$. For example, length $|F|=128$ while the number of pairs $n=2^{24} \Rightarrow m=\floor{\log(n)}+1=25$.
	\item compute a mapping function $M: \bool^\sigma \rightarrow \bool^m$ that represents each encrypted key $sk_i$ in $m$ bit locations defined by $B$, called as mapped encrypted key $\tilde{sk}_{i}=M(sk_i)=sk^{b_1}_i\ldots sk^{b_m}_i$
	\item generate/pad $(2^m-n)$ distinct strings $\tilde{sk}_{n+i}$ length $m$ so that $2^m$ distinct $\tilde{sk}_{i}$ fills out of all possible values of domain $\bool^m$.
	\item 
	\begin{enumerate}
		\item for $1\leq i \leq n$, $\SS$ sends RO hash of the mapped encrypted key $\tilde{sk}_{i}$ along with each encryption string $z_i = \Enc(sk_i,y_i)$
		\item for $n < i \leq 2^m$, $\SS$ sends RO hash of $\tilde{sk}_{i}$ along with $z_i$, where $z_i$ is random string.
	\end{enumerate}
	\item send the mapping function $M$, and set $B=\{b_1,  \ldots, b_m\}$	to $\RR$
\end{enumerate}


By adding on these above steps, $\RR$ knows function $M$ and $m$ bit positions $B=\{b_1,  \ldots, b_m\}$, he computes his mapped encrypted key as $\tilde{sk^*}=M(sk^*)$, and knows which cipher-text he can decrypt using his decrypted key $sk^*$. Note that if his input value $x^*$  is in the sender's set $\{x_i\}$, there exists $i \in [n]$ such that his key $sk^*$ is equal to the encrypted key $sk_i$, thus he can decrypt a corresponding \textit{true} cipher-text $z_i = \Enc(sk_i,y_i)$ using his $sk^*$, and get the \textit{true} value as $y_i =\Dec\big(sk^*, \Enc(sk_i,y_i)\big)$. Otherwise, he decrypts either a ciphertext $z_i = \Enc(sk_i,y_i)$ with a wrong key $sk^* \neq sk_i$ or a random ciphertext $z_i$ created by $\SS$ at the step 4(b).


Moreover, we require an encryption scheme such that for all $m$ the distribution $Enc(sk, m)$  is pseudorandom induced by the pseudorandom distribution of both the encrypted key $sk$ and the plain text $m$.  In other words,the encryption scheme is one-time secure with a random choice of the encrypted key. Our \OPPRF protocol is presented in \figureref{fig:Cons1ssot}. 

\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of \SS:} $n$ points  
				$\P=\{ (x_0, y_0), \ldots, (x_{n-1}, y_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$; and $y_i \in \{0,1\}^\ell$ in pseudorandom distribution
				
				\medskip
				
				{\sc Input of \RR:} selection strings $x^* \in \bool^*$.
				
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
					\item  A \batchOPRF function $\widetilde F$ with output length $\sigma$	
					
					\item A mapping function $M:\bool^\sigma \to \bool^m$, where $m=\floor{\log(n)}+1$ as defined above.
					\item A random hash  $H:\bool^m \to \bool^\kappa$, 
					\item A one-time pad encryption scheme $\Enc$ as defined above.
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item the parties performs a \batchOPRF with sender \SS\ and receiver \RR\
				\begin{enumerate}
					\item \SS\ receives $n$ random keys $k=\{(k^*,k'_i)\}$, 					
					\item \RR\ receives $sk^*=F_k(x^*)$ with no information about the keys $k$
					\item $\forall$ $0\leq i < \L$, \SS\ computes $sk_i = F_k(x_i)$.
				\end{enumerate}
				
				\item \SS\ chooses $m$ bit positions at random $B=\{b_1,  \ldots, b_m\}$, under which the $n$ values $\{sk_i\}^{n-1}_0$ are distinct; sends the set of $B$ to \RR 
				
				\item 
				\begin{enumerate}
					\item $\forall$ $0\leq i < \L$, \SS\ computes the mapped value $\tilde{sk}_{i} = M(sk_i)=sk^{b_1}_i\ldots sk^{b_m}_i$
					\item $\forall$ $\L \leq i < 2^m$, \SS\ pads $2^m-n$ distinct values $\tilde{sk}_{i} \from\bool^m$ at random, such that all $2^m$ values $\tilde{sk}_{i}, i \in [0, 2^m-1]$, are distinct and fill out of the domain $\bool^m$.		
				\end{enumerate}
				\item  
				\begin{enumerate}
					\item $\forall$ $0\leq i < \L$, \SS\ computes $z_i = \Enc(sk_i, y_i)$
					\item $\forall$ $\L \leq i < 2^m$, \SS\ choose $z_i \from\bool^\kappa$ at random
				\end{enumerate}
				\item $\forall$ $0\leq i < 2^m$, \SS\ sends $\{H(\tilde{sk}_{i}), z_i\}$ to \RR\
				
				\item \RR\ receives $Y=\{H(\tilde{sk}_{i}), z_i\}$, $i\in[2^\numinst]$ and does the following: 
				\begin{enumerate}
					\item computes $\tilde{sk^*} = M(sk^*)$
					\item find $i$ such that $H(\tilde{sk^*})= H(\tilde{sk_i})$
					\item output $y^*=\Dec(sk^*, z_i)$
				\end{enumerate}				
				
			\end{enumerate}				
		\end{minipage}
	}
	\caption{1-out-of-$n$ \OPPRF protocol}
	\label{fig:Cons1ssot}
\end{figure}


\begin{theorem} (Correctness)
	\label{thm:sotcorr}
	In semi-honest setting, the sender \SS\ inputs $n$ points $\P=\{ (x_0, y_0), \ldots, (x_{n-1}, y_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$,  and $y_i \in \{0,1\}^\ell$ in pseudorandom distribution.  The receiver \RR\ inputs $x^*$. After running protocol in \figureref{fig:Cons1ssot}, \RR\ receives $y_i$ if $x^*=x_i$, or random value $\hat{y}$ if no such $i$ exists, where $\hat{y}$ depends on $\P$ and is indistinguishable with all values $y_i$
\end{theorem}
\begin{proof}
	In step 3(b), \SS\ chooses $2^m-n$ distinct values $sk_i$ to fill out all cases of value $\tilde{sk_i}$ in the domain $\bool^m$. There exists an unique value $i \in [0, 2^m-1]$ such that $\tilde{sk^*}  = \tilde{sk_i}$. \RR\  obtains the corresponding ciphertext $z_i$ based on the value of $H(\tilde{sk^*})$.  Let's consider two following cases:
	\begin{enumerate}
		\item $\exists i \in [\L]$, $x^*=x_i$: it is easy to see from \batchOPRF that $F_k(x^*)=F_k(x_i) \Rightarrow sk^* = sk_i$. Thus, \RR\ have a ``corrected" decrypted key to decrypt the  ciphertext $z_i = \Enc(sk_i, y_i)$, and gets the value $y_i$.
		
		\item $\forall i \in [\L]$, $x^*\neq x_i$: from the properties of \batchOPRF protocol, $\forall i \in [\L],  F_k(x^*) \ne F_k(x_i) \Rightarrow sk^* \ne sk_i$. It means that \RR\ have not the ``corrected" decrypted key. There are two possible cases:
		\begin{enumerate}
			
			\item the ciphertext $z_i= \Enc(sk_i, y_i)$ from step 4(a): Since our $\Enc$ scheme is one-time pad, and the distribution of both the encrypted key $sk_i$ and plain text $y_i$ are pseudorandom. Thus, \RR\ computes  $\hat{y}=\Dec(sk^*,\Enc(sk_i,y_i))=sk^* \oplus sk_i \oplus y_i$. The decrypted text  $\hat{y}$ is random, indistinguishable with all values $y_i$
			 
			\item $z_i \from\bool^\kappa$ at random from step 4(b):  \RR\  obtains the random ciphertext, decrypts it using his key $sk^*=F_k(x^*)$, and gets the random decrypted text $\hat{y}$.
		\end{enumerate}
		

	\end{enumerate}
	Hence, the protocol is correct.
\end{proof}


In order to show that both parties do not learn any additional information more than in the ideal functionality defined by \ref{fig:1ssotfunc}, our protocol must satisfy two following properties:
\begin{itemize}
	\item the view of a semi-honest sender \SS\ are indistinguishable in the case that \RR\  inputs $x$ and the case that his input is $x'$.  
	\item  the view of semi-honest receivers \RR\ in the real protocol and his view in the ideal protocol on any inputs $\P=\{ (x_0, y_0), \ldots, (x_{n-1}, y_{n-1}) \}$ of the sender \SS\ are indistinguishable. Especially, the view of \RR\ in case that his value $x^*$ is in the keyword set $\{x_i\}$ of \SS\ and it is \textit{not} in this set, are indistinguishable.
\end{itemize}


\begin{theorem}(Privacy)
	\label{thm:sotpriv}
	The \OPPRF protocol in \figureref{fig:Cons1ssot} securely realizes the  functionality of \figureref{fig:1ssotfunc} in the presence of semi-honest adversaries, provided that:
	\begin{itemize}\addtolength{\itemsep}{-6pt}
		\item  A \batchOPRF function $F_k$ with random key $k$ and output length $\kappa$.
		\item A mapping function $M:\bool^\kappa \to \bool^m$, where $m=\floor{\log(n)}+1$ as defined above.
		\item A $\kappa$-RO hash  $H:\bool^m \to \bool^\kappa$, 
		\item A one-time pad encryption scheme $\Enc$.
	\end{itemize}
	Here,  $\kappa$ is the computational security parameter.
\end{theorem}

\begin{proof}
	
	\medskip
	\noindent{\bf Simulating \SS.} 
	According the privacy of the \batchOPRF protocols~\cite{CCS:KKRT16}, it is trivial to argue that the view of a semi-honest \SS\ can be perfectly simulated. Indeed, the view of \SS\ in the protocol is a random key $k$ received from the \batchOPRF and uniformly random OPRF values $F_k(x_i)$. Therefore, the view of a semi-honest sender \SS\, in the case that \RR\  uses $x$ and the case that he uses  $x'$, are indistinguishable. 
	
	\medskip
	\noindent{\bf Simulating \RR.} On the view of a semi-honest receiver \RR\ in the protocol, the only external messages it receives are the \batchOPRF output $sk^*=F_k(x^*)$ at step 1(a), the $m$ bit positions $B=\{b_1,  \ldots, b_m\}$ that leak \RR\ to know $m$ bit positions of the encrypted keys $sk_i$ distinct in step 2, and the set $Y$ in step 6. Therefore, the simulated view is as follows:
	\begin{itemize}
		\item Call the ideal \OPPRF functionality with input $x^*$. Let $z$ denote as the output received from ideal-world trusted party TP.
		
		\item Call the ideal \batchOPRF functionality with input $x^*$. Let $sk^*=F_k(x^*)$ denote as the output received from ideal-world trusted party TP.
		
		
		\item Chooses $m$ bit positions at random $B=\{b_1,  \ldots, b_m\}$ and send it to \RR\ on behalf of $\SS$ in step 2.
		
		\item In step 6, simulate the $Y$ messages from $\SS$ as follows:
		compute  $\tilde{sk^*} = M( sk^*)$, and $ y= \Dec( sk^*, z)$, and set a pair $\{H(\tilde{sk^*}), y \}$ to be a random permutation of $Y$ and $2^m-1$ other random pairs.
		
	\end{itemize}
	
	To prove that this simulated view is indistinguishable from the real one, we first consider the decrypted key value that \SS\ uses in $\Enc$ scheme. The encrypted key is the output of \batchOPRF, thus it is a pseudorandom string. However, the protocol also gives knowledge of:
		\begin{itemize}
		\item $m$ bit positions of the encrypted keys $sk_i$ in which the keys are distinct  
		\item	the RO hash of $m$ bit string of the key as $H(M( sk_i))$.
       \end{itemize}
	 In the worst case, \RR\ can guess $m$ bit string of the encrypted key. Because the output length of \batchOPRF is $\sigma=\kappa+m$ in our protocol, probability for \RR\ learning the key is $1/2^\kappa$. Therefore, choosing $m$ bit positions in step 2 can be simulated independently on the input of $\SS$. In other words, step 1(a), step 2, and step 6(a) are perfectly simulated.
	
	Now, consider the one-time pad encrypted scheme $\Enc$,  we require the distribution of the encrypted key and the plain text to be pseudorandom, thus the real view is indistinguishable from the one in which value of the form  $\Enc(sk_i, y_i)$ in step 4(a) are replaced with random string in step 4(b). 
	
	From the above observation, if \RR\ input value $x^*$ is not in the keyword set $\{x_i\}$ of \SS\, then the corresponding ciphertext is chosen uniformly. The security of $\Enc$ implies that these ciphertexts are indistinguishable from random strings. In addition, the encrypted key is indistinguishable in the case that search word is in the keyword set or not.  Hence, we see that the simulated view is indistinguishable from the real view, and the protocol is secure.
\end{proof}

\subsection{Non-adaptive \OPPRF construction}
\label{sect:constrnSSOT}
We now present the non-adaptive \OPPRF construction which allows the receiver does multiple \OPPRF queries, but the queries must defined before running the protocol. Since our \OPPRF protocol is based on \textit{batch} related-key OPRF (\batchOPRF), this protocol shows an efficient solution to reduce the costs in this non-adaptive setting, and have application to our multi-party private set intersection described in \sectionref{sec:psi}. The basic idea of the construction is to use the \textit{hashing to bin} technique that is very popular in two-party PSI protocols~\cite{DBLP:conf/uss/Pinkas0SZ15,DBLP:conf/uss/Pinkas0Z14}. Our  non-adaptive \OPPRF protocol is presented in \figureref{fig:Consnssot}. 


\begin{figure}[h]\centering
	\framebox{
		\begin{minipage}{0.95\linewidth}
			\noindent{
				\\
				{\sc Input of \SS:} $n$ points   
				$\P=\{ (x_0, y_0), \ldots, (x_{n-1}, y_{n-1}) \}$, where $x_i \in \{0,1\}^*$, $x_i \ne x_j$;  and $y_i \in \{0,1\}^\ell$ in pseudorandom distribution
				
				\medskip
				
				
				{\sc Input of \RR:} $m$ selection strings $\{x^*_1, \ldots, x^*_m\}$, where $x_i \in \{0,1\}^*$.
				
				
				\medskip
				
				{\sc Parameters:}
				\begin{itemize}\addtolength{\itemsep}{-6pt}
					\item   1-out-of-n \OPPRF function $F$;					 
					\item three random hash $\{H_1, H_2, H_3\}: \{ 0,1\}^* \to [1.2m]$ 
					\item  max. stash size $s$ as defined in Table~\ref{tbl:params}
					\item max. number of items in $\SS$'s bin $\gamma$, where $\gamma$ as defined in Table~\ref{tbl:params}
				\end{itemize}
			}
			
			{\sc Protocol:}
			
			\begin{enumerate}
				\addtocounter{enumi}{0}
				\item \RR\ hashes his items $X^*=\{x^*_0, \ldots, x^*_{m-1}\}$ into $1.2m$ bins using Cuckoo hashing defined by 3 hash functions $\{H_1, H_2, H_3\}$. After the certain number of times, if the insertion attempts of the item $x^*_i$ to $[1.2n]$ bins  fails,  \RR\ put this item is in the stash bins in an arbitrary order; otherwise $x^*_i$ is in the bin \#$b(x^*_i) \in [1.2m]$.  
				\\
				For $i \in [1.2m+s]$, if the bin \#$i$ is empty, then pad this bin using a dummy value $r_i$; otherwise if $x^*_j$ is in bin \#$i$ then set $r_i = x^*_j$. 
				
				\item \SS\ hashes his items $X=\{x_0, \ldots, x_{n-1}\}$ into $1.2m$ bins using 3 hash functions $\{H_1, H_2, H_3\}$. For $i \in [1.2m]$, index all $x_j$ is in bin \#$i$ as $r_{i,j}$, and pad this bin \#$i$ to $\gamma$ items using distinct dummy values $r_{i,k}$; for $i \in [s]$, pad this bin \#$i$ by the set $X$.
				
				\item For $i \in [1.2m]$  the parties performs a 1-out-of-n \OPPRF protocol with sender \SS\ and receiver \RR\
				\begin{enumerate}				
					\item \SS\ inputs $\gamma$ points $\P_\gamma=\{(r_{i,j}, \hat{y_j})\}$, where:					
					\[
					\hat{y_j})= 
					\begin{cases}
					y_i,& \text{if } r_{i,j}:=x_j\\
					\text{random},              & \text{otherwise}
					\end{cases}
					\]			
						\item \RR\ inputs the value $r_i$	
					\item \SS\ receives $\gamma$ random keys $k_i=\{(k^*,k'_{i,j})\}$, 
							
					\item \RR\ outputs $F( \P_\gamma,k_i, r_i)$
				\end{enumerate}
				
				\item For $ 1.2m \leq i < s$  the parties performs a 1-out-of-n \OPPRF protocol with sender \SS\ and receiver \RR\
				\begin{enumerate}
						\item \SS\ inputs $n$ points $\P$
						\item \RR\ inputs the value $r_i$ 
						\item \SS\ receives $n$ random keys $k_i=\{(k^*,k'_{i,j})\}$, 
					\item \RR\ outputs $F( \P,k_i, r_i)$	
				\end{enumerate}
				
			\end{enumerate}				
		\end{minipage}
	}
	\caption{$m$-out-of-$n$ non-adaptive \OPPRF protocol}
	\label{fig:Consnssot}
\end{figure}

\begin{table}\centering
	\framebox{
		\begin{minipage}{0.9\linewidth}\centering
			\begin{tabular}{c | c c c }
				$n$ &  $\beta$ & $s$ \\
				\hline
				$2^8$    & 24& 12  \\
				$2^{12}$ & 25& 6  \\
				$2^{16}$ & 26& 4 \\
				$2^{20}$ & 27& 3  \\
				$2^{24}$ &28 & 2  \\
			\end{tabular}
		\end{minipage}
	}
	
	\caption{\todo{recalculate this table for probability finding the diff bit locations} Parameters used in \figureref{fig:Consnssot}. $n$ is the size of the parties' input sets; $\beta$ is the maximum bin size for simple hashing; $s$ is the maximum hash size for Cuckoo hashing}
	\label{tbl:params}
\end{table}

The correctness of the non-adaptive \OPPRF protocol can be trivially achieved from \theoremref{thm:sotcorr}. For the security, the main difference of the construction with the above 1-out-of-n \OPPRF construction is in that in the non-adaptive setting, \SS\ uses Simple hashing and \RR\ uses Cuckoo hashing to assign their item to the bin before running 1-out-of-n \OPPRF protocol. The security of the hashing to bin technique had been proved in ~\cite{eprint:PSZ16} when using the parameters defined in Table~\ref{tbl:params}. Therefore, we can skip the proof of correctness and privacy of the protocol in \figureref{fig:Consnssot}

\todo{describe parameter in Table \ref{tbl:params}}

%\begin{theorem}(Privacy)
%	\label{thm:nsotpriv}
%	The non-adaptive \OPPRF protocol in \figureref{fig:Consnssot} securely realizes the  functionality of \figureref{fig:nssotfunc} in the presence of semi-honest adversaries, provided that:
%	\begin{itemize}\addtolength{\itemsep}{-6pt}
%		\item  a secure 1-out-of-n \OPPRF protocol in \figureref{fig:Cons1ssot} 
%	\item three random hash $\{H_1, H_2, H_3\}: \{ 0,1\}^* \to [1.2m]$ 
%	\item  max. stash size $s$, and max. number of items in $\SS$'s bin $\gamma$ as defined in Table~\ref{tbl:params}
%	\end{itemize}
%\end{theorem}
%
%\begin{proof}
%The proof of security of the non-adaptive \OPPRF construction is very similar to that of  \theoremref{thm:sotpriv}. Most importantly,
%\end{proof}
